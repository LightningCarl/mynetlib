负载发生器的设计与实现
一、负载发生器的功能
1）建立跟服务器的多个连接，发送指定大小的数据过去。
2）监听服务器发送过来的消息事件
3）根据epoll反馈的信号来完成数据接收、数据发送、错误处理
二、概要设计
模块一：通信的建立和断开
1）SocketAddr类：保存IP和端口。
2）TcpSocket类：通信的建立和断开。数据成员为SocketAddr和fd，提供了创建套接字（ generateFd() )、连接服务器（connect()）、关闭套接字（ closeFd() ）等接口。
模块二：创建多个跟服务器的连接
1）center类：通过用户输入连接数，利用for循环，创建所需数量的agent类，并对其进行初始化，发送到服务器的连接请求。
模块三：活跃事件的监听和信号的通知
1）epollEvent类：用于保存epoll事件和agent类的ID、修改epoll事件。其数据成员为m_fd，m_event，m_indexId。将前两个变量传递给Epoll类中doEvent()接口，可以实现事件的增加、修改和删除。由于新建epoll事件到epoll的红黑树上的时候，epoll_event的数据域保存指向epollEvent类的指针，故可以通过m_indexId在AgentManager类中查找到对应的具体agent类（TcpCommunicateAgent或TcplistenAgent）。
2）Epoll类：建立epoll机制、创建活跃事件数组、以及对事件信号的监控和通知。数据成员为m_epfd，m_eventSize，m_finished，m_events。由initEpoll()封装epoll_create()及epoll的活跃事件数。接口Run()封装了epoll_wait()及对活跃事件处理的循环结构。先获得活跃的事件个数，作为一次循环的执行次数。然后依次获取epoll_even的事件信号及返回的epollEvent类地址，在AgentManager中找到对应agent处理上述事件。doTaske()及finish()用于回收结束了会话的TcpCommunicateAgent类。
模块四：Agent类对事件的处理
初始化epoll机制和connect后，就可以监听服务器反馈的到达。
若收到套接字已连接的信号，则修改本端agent中的连接标记为已连接，然后向服务器发送指定大小的数据，将发送时间t1记录在报文的头部。
若未连接成功，则检查重连次数是否超过指定值。未超过的话，重新调用connect进行连接。
若超过重连次数，则结束会话，回收agent。
若触发的epoll信号是EPOLLOIN，则调用recvData()进行接收。
从头部中读取客户端发送时间、服务器接收时间、服务器发送时间，再根据公式计算往返时间t3-t1+t2-(t1+t3)/2，输出到屏幕。根据负载大小申请缓冲区，将数据写进缓冲区。
若epoll触发的是EPOLLOUT信号，则继续向服务器发送数据。在发送数据的时候将发送时间填入头部。
服务器修改：在agent类中，将缓冲区的管理分离出来，用于接收数据和发送数据。有新数据到达时，先读区报文头部，将数据读到一个动态缓冲区中，并在头部中记录收到消息的时间t2。当下次EPOLLOUT事件触发时，在头部中记录发送时间t3，从发送缓冲区中将数据一起写到套接字，发送到客户端。
AgentManager类用于agent类的生命周期的处理，包括：
1）创建并初始化一个新的具体agent类。
2）对结束会话的TcpCommunicateAgent类进行回收。
3）以及在触发epoll事件时通过epoll的活跃事件数组返回的epollEvent类中的indexID来定位此事件对应的处理者——TcpCommunicateAgent或TcplistenAgent。
4）当本次epoll活跃事件数组中的所有事件会话结束后，回收本次回收队列上所有的TcpCommunicateAgent类。
最后，为了提供Epoll类和AgentManager类的全局唯一访问点，创建了一个singleton类，派生出Epoll类和AgentManager类。
三、类图
四、事件的处理过程
1）服务器已连接。
若在epoll循环中收到服务器已连接信号，则利用AgentManager类找到相应的agent，修改agent的连接标识为已连接，再使用connectAfter()发送数据到服务器。
2）重连。
若在epoll循环中收到连接出错信号，则调用connect()尝试再次建立连接，然后等待下次的已连接信号或出错信号的到来，做相应的处理。
3）回收。
若重连多次失败，则放弃连接，回收agent资源。
2）可读。
新连接请求到达后，触发EPOLLIN事件，从事件数组中得到epollEvent类，其中存有处理此事件的TcpCommunicateAgent类的ID，通过在AgentManager类中查找得到TcpCommunicateAgent类，然后此具体类去执行recvData()。首先读数据头部，再读取负载，将负载里的数据写入缓冲区中。
3）可写。
新连接请求到达后，触发EPOLLOUT事件，从事件数组中得到epollEvent类，其中存有处理此事件的TcpCommunicateAgent类的ID，通过在AgentManager类中查找得到TcpCommunicateAgent类，然后此具体类去执行sendData()，将数据读出，读出的数据要加上头部和发送时间。

负载发生器的设计与实现
一、负载发生器的功能
1）建立跟服务器的多个连接，发送指定大小的数据过去。
2）监听服务器发送过来的消息事件
3）根据epoll反馈的信号来完成数据接收、数据发送、错误处理
二、概要设计
模块一：通信的建立和断开
1）SocketAddr类：保存IP和端口。
2）TcpSocket类：通信的建立和断开。数据成员为SocketAddr和fd，提供了创建套接字（ generateFd() )、连接服务器（connect()）、关闭套接字（ closeFd() ）等接口。
模块二：创建多个跟服务器的连接
1）center类：通过用户输入连接数，利用for循环，创建所需数量的agent类，并对其进行初始化，发送到服务器的连接请求。
模块三：活跃事件的监听和信号的通知
1）epollEvent类：用于保存epoll事件和agent类的ID、修改epoll事件。其数据成员为m_fd，m_event，m_indexId。将前两个变量传递给Epoll类中doEvent()接口，可以实现事件的增加、修改和删除。由于新建epoll事件到epoll的红黑树上的时候，epoll_event的数据域保存指向epollEvent类的指针，故可以通过m_indexId在AgentManager类中查找到对应的具体agent类（TcpCommunicateAgent或TcplistenAgent）。
2）Epoll类：建立epoll机制、创建活跃事件数组、以及对事件信号的监控和通知。数据成员为m_epfd，m_eventSize，m_finished，m_events。由initEpoll()封装epoll_create()及epoll的活跃事件数。接口Run()封装了epoll_wait()及对活跃事件处理的循环结构。先获得活跃的事件个数，作为一次循环的执行次数。然后依次获取epoll_even的事件信号及返回的epollEvent类地址，在AgentManager中找到对应agent处理上述事件。doTaske()及finish()用于回收结束了会话的TcpCommunicateAgent类。
模块四：Agent类对事件的处理
初始化epoll机制和connect后，就可以监听服务器反馈的到达。
若收到套接字已连接的信号，则修改本端agent中的连接标记为已连接，然后向服务器发送指定大小的数据，将发送时间t1记录在报文的头部。
若未连接成功，则检查重连次数是否超过指定值。未超过的话，重新调用connect进行连接。
若超过重连次数，则结束会话，回收agent。
若触发的epoll信号是EPOLLOIN，则调用recvData()进行接收。
从头部中读取客户端发送时间、服务器接收时间、服务器发送时间，再根据公式计算往返时间t3-t1+t2-(t1+t3)/2，输出到屏幕。根据负载大小申请缓冲区，将数据写进缓冲区。
若epoll触发的是EPOLLOUT信号，则继续向服务器发送数据。在发送数据的时候将发送时间填入头部。
服务器修改：在agent类中，将缓冲区的管理分离出来，用于接收数据和发送数据。有新数据到达时，先读区报文头部，将数据读到一个动态缓冲区中，并在头部中记录收到消息的时间t2。当下次EPOLLOUT事件触发时，在头部中记录发送时间t3，从发送缓冲区中将数据一起写到套接字，发送到客户端。
AgentManager类用于agent类的生命周期的处理，包括：
1）创建并初始化一个新的具体agent类。
2）对结束会话的TcpCommunicateAgent类进行回收。
3）以及在触发epoll事件时通过epoll的活跃事件数组返回的epollEvent类中的indexID来定位此事件对应的处理者——TcpCommunicateAgent或TcplistenAgent。
4）当本次epoll活跃事件数组中的所有事件会话结束后，回收本次回收队列上所有的TcpCommunicateAgent类。
最后，为了提供Epoll类和AgentManager类的全局唯一访问点，创建了一个singleton类，派生出Epoll类和AgentManager类。
三、类图
四、事件的处理过程
1）服务器已连接。
若在epoll循环中收到服务器已连接信号，则利用AgentManager类找到相应的agent，修改agent的连接标识为已连接，再使用connectAfter()发送数据到服务器。
2）重连。
若在epoll循环中收到连接出错信号，则调用connect()尝试再次建立连接，然后等待下次的已连接信号或出错信号的到来，做相应的处理。
3）回收。
若重连多次失败，则放弃连接，回收agent资源。
2）可读。
新连接请求到达后，触发EPOLLIN事件，从事件数组中得到epollEvent类，其中存有处理此事件的TcpCommunicateAgent类的ID，通过在AgentManager类中查找得到TcpCommunicateAgent类，然后此具体类去执行recvData()。首先读数据头部，再读取负载，将负载里的数据写入缓冲区中。
3）可写。
新连接请求到达后，触发EPOLLOUT事件，从事件数组中得到epollEvent类，其中存有处理此事件的TcpCommunicateAgent类的ID，通过在AgentManager类中查找得到TcpCommunicateAgent类，然后此具体类去执行sendData()，将数据读出，读出的数据要加上头部和发送时间。

负载发生器的设计与实现
一、负载发生器的功能
1）建立跟服务器的多个连接，发送指定大小的数据过去。
2）监听服务器发送过来的消息事件
3）根据epoll反馈的信号来完成数据接收、数据发送、错误处理
二、概要设计
模块一：通信的建立和断开
1）SocketAddr类：保存IP和端口。
2）TcpSocket类：通信的建立和断开。数据成员为SocketAddr和fd，提供了创建套接字（ generateFd() )、连接服务器（connect()）、关闭套接字（ closeFd() ）等接口。
模块二：创建多个跟服务器的连接
1）center类：通过用户输入连接数，利用for循环，创建所需数量的agent类，并对其进行初始化，发送到服务器的连接请求。
模块三：活跃事件的监听和信号的通知
1）epollEvent类：用于保存epoll事件和agent类的ID、修改epoll事件。其数据成员为m_fd，m_event，m_indexId。将前两个变量传递给Epoll类中doEvent()接口，可以实现事件的增加、修改和删除。由于新建epoll事件到epoll的红黑树上的时候，epoll_event的数据域保存指向epollEvent类的指针，故可以通过m_indexId在AgentManager类中查找到对应的具体agent类（TcpCommunicateAgent或TcplistenAgent）。
2）Epoll类：建立epoll机制、创建活跃事件数组、以及对事件信号的监控和通知。数据成员为m_epfd，m_eventSize，m_finished，m_events。由initEpoll()封装epoll_create()及epoll的活跃事件数。接口Run()封装了epoll_wait()及对活跃事件处理的循环结构。先获得活跃的事件个数，作为一次循环的执行次数。然后依次获取epoll_even的事件信号及返回的epollEvent类地址，在AgentManager中找到对应agent处理上述事件。doTaske()及finish()用于回收结束了会话的TcpCommunicateAgent类。
模块四：Agent类对事件的处理
初始化epoll机制和connect后，就可以监听服务器反馈的到达。
若收到套接字已连接的信号，则修改本端agent中的连接标记为已连接，然后向服务器发送指定大小的数据，将发送时间t1记录在报文的头部。
若未连接成功，则检查重连次数是否超过指定值。未超过的话，重新调用connect进行连接。
若超过重连次数，则结束会话，回收agent。
若触发的epoll信号是EPOLLOIN，则调用recvData()进行接收。
从头部中读取客户端发送时间、服务器接收时间、服务器发送时间，再根据公式计算往返时间t3-t1+t2-(t1+t3)/2，输出到屏幕。根据负载大小申请缓冲区，将数据写进缓冲区。
若epoll触发的是EPOLLOUT信号，则继续向服务器发送数据。在发送数据的时候将发送时间填入头部。
服务器修改：在agent类中，将缓冲区的管理分离出来，用于接收数据和发送数据。有新数据到达时，先读区报文头部，将数据读到一个动态缓冲区中，并在头部中记录收到消息的时间t2。当下次EPOLLOUT事件触发时，在头部中记录发送时间t3，从发送缓冲区中将数据一起写到套接字，发送到客户端。
AgentManager类用于agent类的生命周期的处理，包括：
1）创建并初始化一个新的具体agent类。
2）对结束会话的TcpCommunicateAgent类进行回收。
3）以及在触发epoll事件时通过epoll的活跃事件数组返回的epollEvent类中的indexID来定位此事件对应的处理者——TcpCommunicateAgent或TcplistenAgent。
4）当本次epoll活跃事件数组中的所有事件会话结束后，回收本次回收队列上所有的TcpCommunicateAgent类。
最后，为了提供Epoll类和AgentManager类的全局唯一访问点，创建了一个singleton类，派生出Epoll类和AgentManager类。
三、类图
四、事件的处理过程
1）服务器已连接。
若在epoll循环中收到服务器已连接信号，则利用AgentManager类找到相应的agent，修改agent的连接标识为已连接，再使用connectAfter()发送数据到服务器。
2）重连。
若在epoll循环中收到连接出错信号，则调用connect()尝试再次建立连接，然后等待下次的已连接信号或出错信号的到来，做相应的处理。
3）回收。
若重连多次失败，则放弃连接，回收agent资源。
2）可读。
新连接请求到达后，触发EPOLLIN事件，从事件数组中得到epollEvent类，其中存有处理此事件的TcpCommunicateAgent类的ID，通过在AgentManager类中查找得到TcpCommunicateAgent类，然后此具体类去执行recvData()。首先读数据头部，再读取负载，将负载里的数据写入缓冲区中。
3）可写。
新连接请求到达后，触发EPOLLOUT事件，从事件数组中得到epollEvent类，其中存有处理此事件的TcpCommunicateAgent类的ID，通过在AgentManager类中查找得到TcpCommunicateAgent类，然后此具体类去执行sendData()，将数据读出，读出的数据要加上头部和发送时间。


负载发生器的设计与实现
一、负载发生器的功能
1）建立跟服务器的多个连接，发送指定大小的数据过去。
2）监听服务器发送过来的消息事件
3）根据epoll反馈的信号来完成数据接收、数据发送、错误处理
二、概要设计
模块一：通信的建立和断开
1）SocketAddr类：保存IP和端口。
2）TcpSocket类：通信的建立和断开。数据成员为SocketAddr和fd，提供了创建套接字（ generateFd() )、连接服务器（connect()）、关闭套接字（ closeFd() ）等接口。
模块二：创建多个跟服务器的连接
1）center类：通过用户输入连接数，利用for循环，创建所需数量的agent类，并对其进行初始化，发送到服务器的连接请求。
模块三：活跃事件的监听和信号的通知
1）epollEvent类：用于保存epoll事件和agent类的ID、修改epoll事件。其数据成员为m_fd，m_event，m_indexId。将前两个变量传递给Epoll类中doEvent()接口，可以实现事件的增加、修改和删除。由于新建epoll事件到epoll的红黑树上的时候，epoll_event的数据域保存指向epollEvent类的指针，故可以通过m_indexId在AgentManager类中查找到对应的具体agent类（TcpCommunicateAgent或TcplistenAgent）。
2）Epoll类：建立epoll机制、创建活跃事件数组、以及对事件信号的监控和通知。数据成员为m_epfd，m_eventSize，m_finished，m_events。由initEpoll()封装epoll_create()及epoll的活跃事件数。接口Run()封装了epoll_wait()及对活跃事件处理的循环结构。先获得活跃的事件个数，作为一次循环的执行次数。然后依次获取epoll_even的事件信号及返回的epollEvent类地址，在AgentManager中找到对应agent处理上述事件。doTaske()及finish()用于回收结束了会话的TcpCommunicateAgent类。
模块四：Agent类对事件的处理
初始化epoll机制和connect后，就可以监听服务器反馈的到达。
若收到套接字已连接的信号，则修改本端agent中的连接标记为已连接，然后向服务器发送指定大小的数据，将发送时间t1记录在报文的头部。
若未连接成功，则检查重连次数是否超过指定值。未超过的话，重新调用connect进行连接。
若超过重连次数，则结束会话，回收agent。
若触发的epoll信号是EPOLLOIN，则调用recvData()进行接收。
从头部中读取客户端发送时间、服务器接收时间、服务器发送时间，再根据公式计算往返时间t3-t1+t2-(t1+t3)/2，输出到屏幕。根据负载大小申请缓冲区，将数据写进缓冲区。
若epoll触发的是EPOLLOUT信号，则继续向服务器发送数据。在发送数据的时候将发送时间填入头部。
服务器修改：在agent类中，将缓冲区的管理分离出来，用于接收数据和发送数据。有新数据到达时，先读区报文头部，将数据读到一个动态缓冲区中，并在头部中记录收到消息的时间t2。当下次EPOLLOUT事件触发时，在头部中记录发送时间t3，从发送缓冲区中将数据一起写到套接字，发送到客户端。
AgentManager类用于agent类的生命周期的处理，包括：
1）创建并初始化一个新的具体agent类。
2）对结束会话的TcpCommunicateAgent类进行回收。
3）以及在触发epoll事件时通过epoll的活跃事件数组返回的epollEvent类中的indexID来定位此事件对应的处理者——TcpCommunicateAgent或TcplistenAgent。
4）当本次epoll活跃事件数组中的所有事件会话结束后，回收本次回收队列上所有的TcpCommunicateAgent类。
最后，为了提供Epoll类和AgentManager类的全局唯一访问点，创建了一个singleton类，派生出Epoll类和AgentManager类。
三、类图
四、事件的处理过程
1）服务器已连接。
若在epoll循环中收到服务器已连接信号，则利用AgentManager类找到相应的agent，修改agent的连接标识为已连接，再使用connectAfter()发送数据到服务器。
2）重连。
若在epoll循环中收到连接出错信号，则调用connect()尝试再次建立连接，然后等待下次的已连接信号或出错信号的到来，做相应的处理。
3）回收。
若重连多次失败，则放弃连接，回收agent资源。
2）可读。
新连接请求到达后，触发EPOLLIN事件，从事件数组中得到epollEvent类，其中存有处理此事件的TcpCommunicateAgent类的ID，通过在AgentManager类中查找得到TcpCommunicateAgent类，然后此具体类去执行recvData()。首先读数据头部，再读取负载，将负载里的数据写入缓冲区中。
3）可写。
新连接请求到达后，触发EPOLLOUT事件，从事件数组中得到epollEvent类，其中存有处理此事件的TcpCommunicateAgent类的ID，通过在AgentManager类中查找得到TcpCommunicateAgent类，然后此具体类去执行sendData()，将数据读出，读出的数据要加上头部和发送时间。

负载发生器的设计与实现
一、负载发生器的功能
1）建立跟服务器的多个连接，发送指定大小的数据过去。
2）监听服务器发送过来的消息事件
3）根据epoll反馈的信号来完成数据接收、数据发送、错误处理
二、概要设计
模块一：通信的建立和断开
1）SocketAddr类：保存IP和端口。
2）TcpSocket类：通信的建立和断开。数据成员为SocketAddr和fd，提供了创建套接字（ generateFd() )、连接服务器（connect()）、关闭套接字（ closeFd() ）等接口。
模块二：创建多个跟服务器的连接
1）center类：通过用户输入连接数，利用for循环，创建所需数量的agent类，并对其进行初始化，发送到服务器的连接请求。
模块三：活跃事件的监听和信号的通知
1）epollEvent类：用于保存epoll事件和agent类的ID、修改epoll事件。其数据成员为m_fd，m_event，m_indexId。将前两个变量传递给Epoll类中doEvent()接口，可以实现事件的增加、修改和删除。由于新建epoll事件到epoll的红黑树上的时候，epoll_event的数据域保存指向epollEvent类的指针，故可以通过m_indexId在AgentManager类中查找到对应的具体agent类（TcpCommunicateAgent或TcplistenAgent）。
2）Epoll类：建立epoll机制、创建活跃事件数组、以及对事件信号的监控和通知。数据成员为m_epfd，m_eventSize，m_finished，m_events。由initEpoll()封装epoll_create()及epoll的活跃事件数。接口Run()封装了epoll_wait()及对活跃事件处理的循环结构。先获得活跃的事件个数，作为一次循环的执行次数。然后依次获取epoll_even的事件信号及返回的epollEvent类地址，在AgentManager中找到对应agent处理上述事件。doTaske()及finish()用于回收结束了会话的TcpCommunicateAgent类。
模块四：Agent类对事件的处理
初始化epoll机制和connect后，就可以监听服务器反馈的到达。
若收到套接字已连接的信号，则修改本端agent中的连接标记为已连接，然后向服务器发送指定大小的数据，将发送时间t1记录在报文的头部。
若未连接成功，则检查重连次数是否超过指定值。未超过的话，重新调用connect进行连接。
若超过重连次数，则结束会话，回收agent。
若触发的epoll信号是EPOLLOIN，则调用recvData()进行接收。
从头部中读取客户端发送时间、服务器接收时间、服务器发送时间，再根据公式计算往返时间t3-t1+t2-(t1+t3)/2，输出到屏幕。根据负载大小申请缓冲区，将数据写进缓冲区。
若epoll触发的是EPOLLOUT信号，则继续向服务器发送数据。在发送数据的时候将发送时间填入头部。
服务器修改：在agent类中，将缓冲区的管理分离出来，用于接收数据和发送数据。有新数据到达时，先读区报文头部，将数据读到一个动态缓冲区中，并在头部中记录收到消息的时间t2。当下次EPOLLOUT事件触发时，在头部中记录发送时间t3，从发送缓冲区中将数据一起写到套接字，发送到客户端。
AgentManager类用于agent类的生命周期的处理，包括：
1）创建并初始化一个新的具体agent类。
2）对结束会话的TcpCommunicateAgent类进行回收。
3）以及在触发epoll事件时通过epoll的活跃事件数组返回的epollEvent类中的indexID来定位此事件对应的处理者——TcpCommunicateAgent或TcplistenAgent。
4）当本次epoll活跃事件数组中的所有事件会话结束后，回收本次回收队列上所有的TcpCommunicateAgent类。
最后，为了提供Epoll类和AgentManager类的全局唯一访问点，创建了一个singleton类，派生出Epoll类和AgentManager类。
三、类图
四、事件的处理过程
1）服务器已连接。
若在epoll循环中收到服务器已连接信号，则利用AgentManager类找到相应的agent，修改agent的连接标识为已连接，再使用connectAfter()发送数据到服务器。
2）重连。
若在epoll循环中收到连接出错信号，则调用connect()尝试再次建立连接，然后等待下次的已连接信号或出错信号的到来，做相应的处理。
3）回收。
若重连多次失败，则放弃连接，回收agent资源。
2）可读。
新连接请求到达后，触发EPOLLIN事件，从事件数组中得到epollEvent类，其中存有处理此事件的TcpCommunicateAgent类的ID，通过在AgentManager类中查找得到TcpCommunicateAgent类，然后此具体类去执行recvData()。首先读数据头部，再读取负载，将负载里的数据写入缓冲区中。
3）可写。
新连接请求到达后，触发EPOLLOUT事件，从事件数组中得到epollEvent类，其中存有处理此事件的TcpCommunicateAgent类的ID，通过在AgentManager类中查找得到TcpCommunicateAgent类，然后此具体类去执行sendData()，将数据读出，读出的数据要加上头部和发送时间。

负载发生器的设计与实现
一、负载发生器的功能
1）建立跟服务器的多个连接，发送指定大小的数据过去。
2）监听服务器发送过来的消息事件
3）根据epoll反馈的信号来完成数据接收、数据发送、错误处理
二、概要设计
模块一：通信的建立和断开
1）SocketAddr类：保存IP和端口。
2）TcpSocket类：通信的建立和断开。数据成员为SocketAddr和fd，提供了创建套接字（ generateFd() )、连接服务器（connect()）、关闭套接字（ closeFd() ）等接口。
模块二：创建多个跟服务器的连接
1）center类：通过用户输入连接数，利用for循环，创建所需数量的agent类，并对其进行初始化，发送到服务器的连接请求。
模块三：活跃事件的监听和信号的通知
1）epollEvent类：用于保存epoll事件和agent类的ID、修改epoll事件。其数据成员为m_fd，m_event，m_indexId。将前两个变量传递给Epoll类中doEvent()接口，可以实现事件的增加、修改和删除。由于新建epoll事件到epoll的红黑树上的时候，epoll_event的数据域保存指向epollEvent类的指针，故可以通过m_indexId在AgentManager类中查找到对应的具体agent类（TcpCommunicateAgent或TcplistenAgent）。
2）Epoll类：建立epoll机制、创建活跃事件数组、以及对事件信号的监控和通知。数据成员为m_epfd，m_eventSize，m_finished，m_events。由initEpoll()封装epoll_create()及epoll的活跃事件数。接口Run()封装了epoll_wait()及对活跃事件处理的循环结构。先获得活跃的事件个数，作为一次循环的执行次数。然后依次获取epoll_even的事件信号及返回的epollEvent类地址，在AgentManager中找到对应agent处理上述事件。doTaske()及finish()用于回收结束了会话的TcpCommunicateAgent类。
模块四：Agent类对事件的处理
初始化epoll机制和connect后，就可以监听服务器反馈的到达。
若收到套接字已连接的信号，则修改本端agent中的连接标记为已连接，然后向服务器发送指定大小的数据，将发送时间t1记录在报文的头部。
若未连接成功，则检查重连次数是否超过指定值。未超过的话，重新调用connect进行连接。
若超过重连次数，则结束会话，回收agent。
若触发的epoll信号是EPOLLOIN，则调用recvData()进行接收。
从头部中读取客户端发送时间、服务器接收时间、服务器发送时间，再根据公式计算往返时间t3-t1+t2-(t1+t3)/2，输出到屏幕。根据负载大小申请缓冲区，将数据写进缓冲区。
若epoll触发的是EPOLLOUT信号，则继续向服务器发送数据。在发送数据的时候将发送时间填入头部。
服务器修改：在agent类中，将缓冲区的管理分离出来，用于接收数据和发送数据。有新数据到达时，先读区报文头部，将数据读到一个动态缓冲区中，并在头部中记录收到消息的时间t2。当下次EPOLLOUT事件触发时，在头部中记录发送时间t3，从发送缓冲区中将数据一起写到套接字，发送到客户端。
AgentManager类用于agent类的生命周期的处理，包括：
1）创建并初始化一个新的具体agent类。
2）对结束会话的TcpCommunicateAgent类进行回收。
3）以及在触发epoll事件时通过epoll的活跃事件数组返回的epollEvent类中的indexID来定位此事件对应的处理者——TcpCommunicateAgent或TcplistenAgent。
4）当本次epoll活跃事件数组中的所有事件会话结束后，回收本次回收队列上所有的TcpCommunicateAgent类。
最后，为了提供Epoll类和AgentManager类的全局唯一访问点，创建了一个singleton类，派生出Epoll类和AgentManager类。
三、类图
四、事件的处理过程
1）服务器已连接。
若在epoll循环中收到服务器已连接信号，则利用AgentManager类找到相应的agent，修改agent的连接标识为已连接，再使用connectAfter()发送数据到服务器。
2）重连。
若在epoll循环中收到连接出错信号，则调用connect()尝试再次建立连接，然后等待下次的已连接信号或出错信号的到来，做相应的处理。
3）回收。
若重连多次失败，则放弃连接，回收agent资源。
2）可读。
新连接请求到达后，触发EPOLLIN事件，从事件数组中得到epollEvent类，其中存有处理此事件的TcpCommunicateAgent类的ID，通过在AgentManager类中查找得到TcpCommunicateAgent类，然后此具体类去执行recvData()。首先读数据头部，再读取负载，将负载里的数据写入缓冲区中。
3）可写。
新连接请求到达后，触发EPOLLOUT事件，从事件数组中得到epollEvent类，其中存有处理此事件的TcpCommunicateAgent类的ID，通过在AgentManager类中查找得到TcpCommunicateAgent类，然后此具体类去执行sendData()，将数据读出，读出的数据要加上头部和发送时间。

负载发生器的设计与实现
一、负载发生器的功能
1）建立跟服务器的多个连接，发送指定大小的数据过去。
2）监听服务器发送过来的消息事件
3）根据epoll反馈的信号来完成数据接收、数据发送、错误处理
二、概要设计
模块一：通信的建立和断开
1）SocketAddr类：保存IP和端口。
2）TcpSocket类：通信的建立和断开。数据成员为SocketAddr和fd，提供了创建套接字（ generateFd() )、连接服务器（connect()）、关闭套接字（ closeFd() ）等接口。
模块二：创建多个跟服务器的连接
1）center类：通过用户输入连接数，利用for循环，创建所需数量的agent类，并对其进行初始化，发送到服务器的连接请求。
模块三：活跃事件的监听和信号的通知
1）epollEvent类：用于保存epoll事件和agent类的ID、修改epoll事件。其数据成员为m_fd，m_event，m_indexId。将前两个变量传递给Epoll类中doEvent()接口，可以实现事件的增加、修改和删除。由于新建epoll事件到epoll的红黑树上的时候，epoll_event的数据域保存指向epollEvent类的指针，故可以通过m_indexId在AgentManager类中查找到对应的具体agent类（TcpCommunicateAgent或TcplistenAgent）。
2）Epoll类：建立epoll机制、创建活跃事件数组、以及对事件信号的监控和通知。数据成员为m_epfd，m_eventSize，m_finished，m_events。由initEpoll()封装epoll_create()及epoll的活跃事件数。接口Run()封装了epoll_wait()及对活跃事件处理的循环结构。先获得活跃的事件个数，作为一次循环的执行次数。然后依次获取epoll_even的事件信号及返回的epollEvent类地址，在AgentManager中找到对应agent处理上述事件。doTaske()及finish()用于回收结束了会话的TcpCommunicateAgent类。
模块四：Agent类对事件的处理
初始化epoll机制和connect后，就可以监听服务器反馈的到达。
若收到套接字已连接的信号，则修改本端agent中的连接标记为已连接，然后向服务器发送指定大小的数据，将发送时间t1记录在报文的头部。
若未连接成功，则检查重连次数是否超过指定值。未超过的话，重新调用connect进行连接。
若超过重连次数，则结束会话，回收agent。
若触发的epoll信号是EPOLLOIN，则调用recvData()进行接收。
从头部中读取客户端发送时间、服务器接收时间、服务器发送时间，再根据公式计算往返时间t3-t1+t2-(t1+t3)/2，输出到屏幕。根据负载大小申请缓冲区，将数据写进缓冲区。
若epoll触发的是EPOLLOUT信号，则继续向服务器发送数据。在发送数据的时候将发送时间填入头部。
服务器修改：在agent类中，将缓冲区的管理分离出来，用于接收数据和发送数据。有新数据到达时，先读区报文头部，将数据读到一个动态缓冲区中，并在头部中记录收到消息的时间t2。当下次EPOLLOUT事件触发时，在头部中记录发送时间t3，从发送缓冲区中将数据一起写到套接字，发送到客户端。
AgentManager类用于agent类的生命周期的处理，包括：
1）创建并初始化一个新的具体agent类。
2）对结束会话的TcpCommunicateAgent类进行回收。
3）以及在触发epoll事件时通过epoll的活跃事件数组返回的epollEvent类中的indexID来定位此事件对应的处理者——TcpCommunicateAgent或TcplistenAgent。
4）当本次epoll活跃事件数组中的所有事件会话结束后，回收本次回收队列上所有的TcpCommunicateAgent类。
最后，为了提供Epoll类和AgentManager类的全局唯一访问点，创建了一个singleton类，派生出Epoll类和AgentManager类。
三、类图
四、事件的处理过程
1）服务器已连接。
若在epoll循环中收到服务器已连接信号，则利用AgentManager类找到相应的agent，修改agent的连接标识为已连接，再使用connectAfter()发送数据到服务器。
2）重连。
若在epoll循环中收到连接出错信号，则调用connect()尝试再次建立连接，然后等待下次的已连接信号或出错信号的到来，做相应的处理。
3）回收。
若重连多次失败，则放弃连接，回收agent资源。
2）可读。
新连接请求到达后，触发EPOLLIN事件，从事件数组中得到epollEvent类，其中存有处理此事件的TcpCommunicateAgent类的ID，通过在AgentManager类中查找得到TcpCommunicateAgent类，然后此具体类去执行recvData()。首先读数据头部，再读取负载，将负载里的数据写入缓冲区中。
3）可写。
新连接请求到达后，触发EPOLLOUT事件，从事件数组中得到epollEvent类，其中存有处理此事件的TcpCommunicateAgent类的ID，通过在AgentManager类中查找得到TcpCommunicateAgent类，然后此具体类去执行sendData()，将数据读出，读出的数据要加上头部和发送时间。